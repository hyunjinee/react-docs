# 프론트엔드에서 MV\* 아키텍쳐란 무엇인가요?

## MVC

좋은 구조의 첫번째 조건은 좋은 분류이다.

UI가 있는 소프트웨어를 만들다 보니 아주 오래전부터 개발자들은 MVC, 즉 Model, View, Controller라는 영역으로 나누면 딱 좋다라는 것을 알게되었다.

- View: 웹 프론트에서는 대개 최종적으로 HTML과 CSS로 만들어지는 결과물을 의미한다.
- Model(데이터): 소프트웨어가 멈춰있는 화면만 있으면 디자인과 다를게 없다. 화면의 어딘가는 실제의 데이터가 반영되어 나타나야하는데 이러한 데이터를 주관하는 영역을 Model이라고 한다.
- Controller: UI 소프트웨어의 본질은 단순하다. Model의 데이터를 받아서 화면에 그리고, 화면으로부터 사용자의 입력을 받아서 Model을 변경한다. 이러한 Model과 View 사이의 중간 역할을 하는 것을 Controller라고 한다.

> UI 소프트웨어는 우선 데이터를 화면에 그리고 우리가 어떤 동작을 취하면 데이터가 바뀐다. 데이터가 바뀌면 다시 화면이 바뀐다.

MVC가 이렇게 나눠진 이유는 화면을 다루는 문제와 데이터를 다루는 문제의 성격이 달라서 분리하고 싶고 Model과 View간의 의존관계를 최소화해서 화면의 수정이 데이터 수정에 영향을 미치지 않고 데이터 수정이 화면의 수정에 영향을 미치지 않고자 함이다.

### 초창기 웹 서비스의 MVC 아키텍처

MVC라는 것에 대한 개념은 이제 확실해졌지만 아키텍쳐의 잣대와 범주는 언어마다 환경마다 다 다르다.

웹 프론트엔드라는 개념도 없던 웹 서비스 초창기 시절의 MVC는 데이터베이스를 모델로 취급하고, HTML과 CSS 그리고 JavaScript까지 포함한 클라이언트 영역을 View로 그리고 가운데서 라우터를 통해 데이터를 처리하고 새로운 HTML을 만들어서 보여주는 백엔드 영역을 Controller라고 취급했다.

그래서 고대 시절 루비 온 레일즈라든지 PHP, JSP등에서는 라우터 영역을 Controller로 정의한 프레임워크등이 많았다.

### jQuery 시절의 MVC 아키텍쳐

프론트엔드라는 역할이 추가되고 특히 ajax라는 기술이 만들어지면서 이제는 HTML을 서버에서 직접 만들 필요가 없게 되었다.

_이때부터 웹 프론트엔드의 MVC 개념이 조금씩 바뀌게 되었다._

- ajax로 부터 받는 데이터를 Model로 취급한다.
- HTML과 CSS로 만들어지는 화면을 View로 취급한다.
- javascript가 중간에서 서버의 데이터를 받아서 화면을 바꾸고 이벤트를 처리해서 서버에 데이터를 전달하는 Controller의 역할을 수행하게 된다.

기존의 서버 라우터에서 하던 어떤 역할들이 이제 클라이언트 자바스크립트가 처리하게 되었고 Database는 백엔드의 역할이며 REST API의 ajax 데이터가 Model이 된다.

![image](https://user-images.githubusercontent.com/63354527/187730078-f5b599ac-620f-4c4e-9547-a8516dcff5cb.png)

jQuery의 역할은 다음과 같다.

- DOM Traversal and Manipulation
- Event Handling
- Ajax

이 당시 가장 중요한 패러다임은 관점의 분리로서 Model과 View의 종속성을 최대한 분리해야한다는 원칙으로 HTML과 jQuery를 따로 관리하는 것이 주효했다.

이후 조금더 MVC스러움을 추구하는 Backbonejs과 같은 프레임워크등이 만들어지기도 했다.

## MVVM 아키텍쳐 angular, react, vue

그 다음 나온 아키텍처가 MVVM이라는 아키텍처이다.

jQuery로 작업을 하다보니 상당히 불편한점을 발견하게 된다. 데이터를 찾아서 데이터를 바꾸고 데이터를 수정하고 이벤트를 연결하고 이벤트를 수정하는 부분들에서 피곤한 반복적인 패턴이 나타난다는 것을 알게 되었다.

서버에서 개바을 할 때에는 HTML이 전체적으로 렌더링으로 되다보니, {{}}, <?= ?>, <%= %>와 같은 치환자로 선언적으로 편하게 개발을 하는 반면 jQuery의 경우 전체 HTML을 갱신했다가는 번쩍거리는 화면을 맞볼 수 있으니 수정해야 할 부분을 일일이 찾아서 수정을 해주어야했다.

> 클라이언트 개발도 서버처럼 템플릿과 같은 선언적인 방식으로 개발할 수 없을까?

이러한 개념을 바탕으로 knockoutjs와 같은 템플릿 바인딩 기반의 라이브러리가 만들어진다. 하지만 이방식이 제일 유명해진 계기는 angularjs이다.

앵귤러는 템플릿과 바인딩이라는 중요한 개념들이 등장하였고 이후로 웹 개발하는 방식의 패러다임이 완전히 바뀌게 된다.

Model이 변하면 View를 수정하고 View에서 이벤트를 받아서 Model을 변경한다는 Controller의 역할은 그대로인데 이를 구현하는 방식이 jQuery와 같은 DOM 조작에서 템플릿과 바인딩을 통한 선언적인 방법으로 변하게된다.

이제 코드에서 DOM을 조작하는 코드가 사라지고 이 기능들은 프레임워크가 담당하게된다. 이제 개발자는 화면에서 그려져야할 데이터만 만들어서 프레임워크에 전달해주면 프레임워크가 알아서 그려준다.

이를 View를 그리는 Model만 다루게 되었다는 의미로 ViewModel이라고 부르며 이 방식을 MVVM이라고 부르게 된다.

이후 나오는 React, Vue, Angular2, Svelte등 어떤 방식의 템플릿과 바인딩 문법을 쓰느냐 방식만 다를뿐 MVVM이라는 아키텍쳐는 그대로 유지되게 된다.

### MVC에서 MVVM으로 오면서 달라진 부분

- 컨트롤러의 반복적인 기능이 선언적인 방식으로 개선되었다.
- Model과 View의 관점을 분리하려 하지 않고 하나의 템플릿으로 관리하려는 방식으로 발전했다. (기존에는 class나 id등 간접적으로 HTML에 접근하려고 했다면 이제는 직접적으로 HTML에 접근하는 방법으로 확장이 되었다.)

## 컴포넌트 그리고 Container-Presenter 패턴

MVVM을 얻은 웹 프론트엔드 개발은 그야말로 무시무시한 생산성 변화를 마지하게된다. 웹의 DOM API를 잘 다루지 못하더라도 비즈니스 로직에만 집중한다면 금방금방 서비스를 만들 수 있게 되었다.

웹 서비스가 발전하면서 이제는 하나의 Page단위가 아니라 Page안에 여러 모듈이 있고 Modal이나 여러 화면들이 하나의 화면에서 구성이 될 수 있도록 발전을 하게된다.

그래서 MVVM이 이제 화면단위가 아니라 조금 더 작게 재사용 할 수 있는 단위로 만들어서 조립을 하는 방식으로 발전을 하게 된다.

이것이 우리는 이미 이제 익숙한 Component 패턴이다.

컴포넌트는 재사용 가능해야한다는 원칙에 따라 가급적 비즈니스 로직을 포함시키지 않으려고 개발을 했다. 비즈니스 로직이 들어가게 되면 컴포넌트의 재활용성은 상당히 떨어지게 된다.

> 비즈니스 로직을 관장하고 있는 컴포넌트를 Container 컴포넌트라 하고 이제 비즈니스 로직을 가지고 있지 않은 데이터만 뿌려주는 형태의 컴포넌트를 Presenter 컴포넌트로 분리하여 최상단 혹은 1depth에 Container를 두고 비즈니스 로직을 관리하는 Container-Presenter 아키텍처가 만들어진다.

![image](https://user-images.githubusercontent.com/63354527/187735441-c99ca455-4f34-4809-8a70-f9ef6355ec95.png)

이렇게 만들게 됐을 때 문제는 컴포넌트 구조가 복잡해짐에 따라 하위에 특정 값을 전달하기 위해서는 중간 레벨에 있는 컴포넌트들은 전부 그 props를 가지고 있어야하는 문제가 발생한다.

이렇게 상단에 있는 데이터를 하단에 있는 props로 보내기 위해서 중간 계층에 있는 props를 하나씩 추가하는 문제를 Props Drilling Problem이라고 한다.

그래서 이러한 문제를 해결하기 위한 새로운 아키텍처를 생각한다.

## FLUX 패턴과 Redux

FLUX 패턴은 이제 MVC의 개념에서 벗어나서 단방향 아키텍쳐(uni-directional architecture)를 만들자는 이야기로 시작한다.

컴포넌트의 재사용과 독립성을 지나치게 강조하다보니 같은 데이터를 공유하는 과정에서 props를 통해서 데이터를 전달하는 문제들로 하여금 Model의 관리가 파편화되는 문제가 발생했다.

![image](https://user-images.githubusercontent.com/63354527/187736545-5415b315-f1b2-4532-a14a-d9a0e6d6b430.png)

기존의 컴포넌트를 지향하는 MVC가 아니라 View를 하나의 범주로 두고 View에서 Action을 호출하면 Dispatcher를 통해 Store라는 공간에 Data가 보관이 되고 다시 뷰로 전달되는 흐름을 설명한다. FLUX는 아키텍처만 공개되었을 뿐 실체는 없었기에 바로 쓰이지는 않았고 아젠다를 만들어주는 정도에서 그쳤다.

### Redux

이후 FLUX 패턴을 이용한 구현체인 Redux가 탄생한다.

기존의 Props Drilling 문제를 정확하게 짚어주었고, Store, Dispatch, Reducer에 대한 개념을 정확하게 다시 정리해주었다.

FLUX 패턴은 View를 각각의 MVC 컴포넌트 관점으로 보는 것이 아니라 하나의 큰 View로 이해하고 View에서는 Dispatch를 통해서 Action을 전달하면 Action은 Reducer를 통해서 Data가 Store에 보관이되고 Store에 있는 데이터는 다시 View로 연결이 되는 방식을 지향한다.

기존의 컴포넌트 단위의 MVC 개념에서 완전히 비즈니스 로직과 View를 분리하면서 이 분리된 개념을 **상태관리**라고 부르게 된다.

MVC에서 FLUX로 오면서 달라진 부분은 다음과 같다.

- 공통적으로 사용되는 비즈니스 로직의 Layer와 View의 Layer를 완전히 분리하여 상태관리라는 방식으로 관리한다.
- 각각의 독립된 컴포넌트가 아니라 하나의 거대한 View 영역으로 간주한다.
- 둘 사이의 관계는 Action과 Reduce라는 인터페이스로 분리하며 Controller는 이제 양방향이 아니라 단방향으로 Cycle을 이루도록 설계한다.

FLUX 패턴은 각 프레임워크 진영에게 많은 영감을 주었으며 프레임워크와 더불어서 본격적인 상태관리 라이브러리들이 만들어지기 시작한다. Redux, Vuex등이 대표적인 상태관리 라이브러리이다.

### FLUX 패턴의 한계

FLUX는 다른 문제에 봉착한다.

1. 러닝 커브
2. 장황한 문법

간단한 구조에서는 앞에서 언급한 Props Drilling이 치명적이지 않았고 상태를 관리하기 위해서 Action, Dispatch, Reducer를 만들고 관리하는데 들어가는 많은 부수적인 코드들로 인해 관리가 되려 어려워진다는 문제가 있었다.

## Observer-Observable Pattern

![image](https://user-images.githubusercontent.com/63354527/187738653-5e0e3fcb-da0d-4368-9258-e5e0d0f9861f.png)

Props Drilling 문제를 다른 식으로 풀어보려는 시각도 나왔다. FLUX와 동일하게 거대한 View와 상태관리인 Model을 나누는 관점은 동일했다.

복잡함을 야기하는 Dispatch와 Action을 배제하고 값이 바뀌면 바뀐 값을 모두에게 전달을 한다는 개념이다.

초창기 Mobx가 이러한 방식을 기반으로 하되 Redux의 영향을 받아 용어는 Action과 Reaction이라는 방식을 취했다.

![image](https://user-images.githubusercontent.com/63354527/187739155-8dbacee4-a87d-45eb-b6ce-afb7d2323746.png)

Angular에서는 Rxjs를 받아들이고 FLUX패턴까지 결합해 FLUX와 Observable이 혼합된 상태관리를 만들기도 했다.

![image](https://user-images.githubusercontent.com/63354527/187739374-017d07bd-8b8e-4974-b488-766856d4049c.png)

## MVI 패턴

웹프론트에서는 cycle.js라는 라이브러리에서 먼저 소개된 개념이다.

![image](https://user-images.githubusercontent.com/63354527/187739522-7c313d41-f8c4-4984-83b6-199ad43e6f4e.png)
기존 FLUX 패턴을 Dispatch와 Action과 Update의 인터페이스를 전부 Observable을 이용한 스트림(Stream)의 하나의 방식으로 만들어 비동기 문제를 해결하고 장황한 문법을 하나의 인터페이스로 만든 점이 인상적이다.

> 이 MVI 아키텍처라는 워딩은 웹에서는 아직 잘 쓰이지 않는데 현재는 ios와 android에서 새로운 아키텍처로 부상하고 있다.

## 현대 웹 프론트엔드의 아키텍처 방향성들

### Context와 hook, props 상속

props drilling 문제라면 새로운 개념을 만들기보다 props만 새로 뚫지 않는 방법등을 제공하면 되지 않느냐는 시각이다. 컴포넌트 트리에서 Context라는 거대한 공통 조상을 만들고 그 Context로부터 데이터를 제공받는 방식이다. 개념적으로는 별도의 Store를 두는 FLUX와 비슷한 느낌이 있어서 최근에는 복잡한 문법을 가지고 만들어야하는 Redux보다는 React의 기본 기능인 Context API를 쓰겠다는 움직임이 생기고 있다.

Svelte에서도 React와 동일한 Context라는 개념을 제공하고 있다. 또한 별도의 props를 선언하지 않고 모든 props를 자식으로 전달해주는 기능들을 제공하고 있다.

### Atomic 패턴 - Recoil, Svelte Store, Vue Composition, jotai

거대한 View 영역과 Store 영역을 나누어 이분법으로 생각하자는 의견에는 동의하나 Action ~ Distach ~ Reducer와 같은 복잡한 구조를 가져야 하는가에 대한 방법에 대해서는 회의적인 시각으로 만들어진 문법이다.

간단한 문법으로 컴포넌트 외부에서 공통의 데이터를 get, set 할 수 있게 하면서 동시에 동기화를 할 수 있는 방향성이다. 이와 더불어 computed, derived, select와 같은 반응형 기능을 제공하여 관련된 데이터의 동시 업데이트를 제공하고 있다.

### React-Query MVC의 개념 확대

React-Query는 이러한 상태관리에 편향되어 있던 시각에서 벗어나 고전적인 ajax를 Model로 간주한다. 대부분의 프론트엔드 개발은 서버 데이터를 CRUD하고 시각으로 그리는 것에 중점이 되어있는데 FLUX나 Atomic은 너무 복잡한 방법이라는 것이다.

## 마치며

패러다임의 확장과 개선이 있기 까지는 많은 시간이 걸린다. 이러한 개선의 시작은 바로 현재의 개발 방식에서 불편함을 느끼는 것이다.

서두에서 언급했던 아키텍처의 시작은 불편한 것을 찾고 하지말아야할 규칙을 찾는 것부터 시작한다. 그리고 그것을 개선하는 방법을 찾음으로써 새로운 패러다임이 생겨나게 된다.

내가 당장 새로운 라이브러리를 개발할 수는없겠지만 언제나 이 불편함을 주시하고 있어야 앞으로 새로운 라이브러리가 나왔을 때 그것이 개선되었는지 아니면 새롭지 않은 기존 라이브러리의 아류인지 판단할 수 있다.

웹은 언제나 무서운 속도로 발전하고 있고 내 코드는 언젠간 레거시가된다. 새로운 것으로 갈아타야할 준비는 언제든지 해야하나 너무 빨리 갈아타도 탈이나도 너무 늦게 갈아타도 문제가 된다.

이러한 웹의 발전 역사와 방향성을 이해하면서 그 안에서 아직도 해결되지 않는 여러 불편함들에 대해서 숙지하고 그것들을 해소해주는 라이브러리나 패러다임에 대해서 빨리 깨닫고 공부해야 할 것을 찾고 새루운 기술로 갈아탈 수 있는 눈을 가질 수 있기를 희망한다.
